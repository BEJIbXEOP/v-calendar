<template>
  <div class="vc-day" :class="dayClasses">
    <!--Highlights-->
    <div v-if="hasHighlights" class="vc-highlights vc-day-layer">
      <div
        v-for="{ key, wrapperClass, class: bgClass, style } in highlights"
        :key="key"
        :class="wrapperClass"
      >
        <div :class="bgClass" :style="style" />
      </div>
    </div>
    <!--Content-->
    <slot
      name="day-content"
      :day="day"
      :attributes="attributes"
      :attribute-cells="attributeCells"
      :dayProps="dayContentProps"
      :dayEvents="dayContentEvents"
      :locale="locale"
    >
      <div
        v-bind="dayContentProps"
        v-on="dayContentEvents"
        v-popover="dayPopover"
      >
        {{ day.label }}
      </div>
    </slot>
    <!--Dots-->
    <div v-if="hasDots" class="vc-day-layer vc-day-box-center-bottom">
      <div class="vc-dots">
        <span
          v-for="{ key, class: bgClass, style } in dots"
          :key="key"
          :class="bgClass"
          :style="style"
        />
      </div>
    </div>
    <!--Bars-->
    <div v-if="hasBars" class="vc-day-layer vc-day-box-center-bottom">
      <div class="vc-bars">
        <span
          v-for="{ key, class: bgClass, style } in bars"
          :key="key"
          :class="bgClass"
          :style="style"
        />
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { PropType, defineComponent, computed } from 'vue';
import { useCalendar } from '../../use/calendar';
import { CalendarDay } from '../../utils/page';
import { Attribute, PopoverConfig } from '../../utils/attribute';
import { arrayHasItems, last, get, defaults } from '../../utils/helpers';
import { popoverDirective } from '../../utils/popovers';
import { DateRangeCell } from '../../utils/date/range';

export default defineComponent({
  directives: { popover: popoverDirective },
  props: {
    day: { type: Object as PropType<CalendarDay>, required: true },
  },
  setup(props, { slots }) {
    const {
      locale,
      theme,
      attributeContext,
      dayPopoverId,
      onDayClick,
      onDayMouseenter,
      onDayMouseleave,
      onDayFocusin,
      onDayFocusout,
      onDayKeydown,
    } = useCalendar();

    const day = computed(() => props.day);
    const attributeCells = computed(() => {
      if (!attributeContext.value) return [];
      return attributeContext.value.getCells(day.value.dayIndex);
    });
    const attributes = computed(() =>
      attributeCells.value.map(cell => cell.data),
    );

    function processPopover(
      { data: attribute }: DateRangeCell<Attribute>,
      { popovers }: { popovers: PopoverConfig[] },
    ) {
      const { key, customData, popover } = attribute;
      if (!popover) return;
      const resolvedPopover = defaults(
        {
          key,
          customData,
          attribute,
        },
        { ...popover },
        {
          visibility: popover.label ? 'hover' : 'click',
          placement: 'bottom',
          isInteractive: !popover.label,
        },
      );
      popovers.splice(0, 0, resolvedPopover);
    }

    const glyphs = computed(() => {
      const result = {
        ...theme.value.prepareRender({}),
        popovers: [],
      };
      attributeCells.value.forEach(cell => {
        theme.value.render(cell, result);
        processPopover(cell, result);
      });
      return result;
    });

    const highlights = computed(() => glyphs.value.highlights);
    const hasHighlights = computed(() => !!arrayHasItems(highlights.value));

    const content = computed(() => glyphs.value.content);

    const dots = computed(() => glyphs.value.dots);
    const hasDots = computed(() => !!arrayHasItems(dots.value));

    const bars = computed(() => glyphs.value.bars);
    const hasBars = computed(() => !!arrayHasItems(bars.value));

    const popovers = computed(() => glyphs.value.popovers);
    const popoverAttrs = computed(() =>
      popovers.value.map((p: any) => p.attribute),
    );

    const dayClasses = computed(() => {
      return [
        'vc-day',
        ...day.value.classes,
        { 'vc-day-box-center-center': !slots['day-content'] },
        { 'is-not-in-month': !props.day.inMonth },
      ];
    });

    const dayContentProps = computed(() => {
      let tabindex;
      if (day.value.isFocusable) {
        tabindex = '0';
      } else {
        tabindex = '-1';
      }
      const classes = [
        'vc-day-content vc-focusable vc-focus vc-attr',
        { 'vc-disabled': day.value.isDisabled },
        get(last(highlights.value), 'contentClass'),
        get(last(content.value), 'class') || '',
      ];
      const style = {
        ...get(last(highlights.value), 'contentStyle'),
        ...get(last(content.value), 'style'),
      };
      return {
        class: classes,
        style,
        tabindex,
        'aria-label': day.value.ariaLabel,
        'aria-disabled': day.value.isDisabled ? true : false,
        role: 'button',
      };
    });

    const dayContentEvents = computed(() => {
      return {
        click(event: MouseEvent) {
          onDayClick(day.value, event);
        },
        mouseenter(event: MouseEvent) {
          onDayMouseenter(day.value, event);
        },
        mouseleave(event: MouseEvent) {
          onDayMouseleave(day.value, event);
        },
        focusin(event: FocusEvent) {
          onDayFocusin(day.value, event);
        },
        focusout(event: FocusEvent) {
          onDayFocusout(day.value, event);
        },
        keydown(event: KeyboardEvent) {
          onDayKeydown(day.value, event);
        },
      };
    });

    const dayPopover = computed(() => {
      if (!arrayHasItems(popovers.value)) return null;
      return defaults(
        {
          id: dayPopoverId.value,
          data: { day, attributes: popoverAttrs.value },
        },
        ...popovers.value,
      );
    });

    return {
      attributes,
      attributeCells,
      bars,
      dayClasses,
      dayContentProps,
      dayContentEvents,
      dayPopover,
      glyphs,
      dots,
      hasDots,
      hasBars,
      highlights,
      hasHighlights,
      locale,
      popovers,
    };
  },
});
</script>
